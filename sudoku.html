<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sudoku</title>
<style>
  :root{
    --bg:#0f1115; --card:#171a21; --accent:#00e5ff; --ok:#37d67a; --warn:#ffb000; --bad:#ff4d4d; --grid:#2a2f3a;
    --text:#e6eef8; --muted:#94a3b8;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text);}
  header{padding:16px 12px; text-align:center; font-weight:800; letter-spacing:.5px;}
  .app{max-width:1000px; margin:0 auto; padding:12px; display:grid; gap:16px; grid-template-columns:1fr;}
  .topbar{display:flex; flex-wrap:wrap; gap:8px; justify-content:center; align-items:center}
  .badge{background:var(--card); border:1px solid var(--grid); padding:6px 10px; border-radius:10px; color:var(--muted)}
  .board-wrap{display:flex; justify-content:center}
  .board{
    width:min(92vw,560px); aspect-ratio:1/1; display:grid; grid-template-columns:repeat(9,1fr); grid-template-rows:repeat(9,1fr);
    background:var(--card); border:3px solid var(--accent); border-radius:14px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.35)
  }
  .cell{
    border:1px solid var(--grid); position:relative; display:flex; align-items:center; justify-content:center; user-select:none;
    font-weight:700; font-size:clamp(18px,5.3vw,28px); cursor:pointer; transition:background .12s ease;
  }
  .cell.lock{color:#cbd5e1}
  .cell.sel{outline:2px solid var(--accent); outline-offset:-2px; z-index:2}
  .cell.same{background:rgba(0,229,255,.08)}
  .cell.peer{background:rgba(255,255,255,.03)}
  .cell.conflict{background:rgba(255,77,77,.18)}
  .cell .notes{
    position:absolute; inset:3px; display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr);
    font-weight:600; font-size:clamp(8px,2.6vw,12px); color:#9aa7b7; gap:1px; pointer-events:none;
  }
  .cell .n{display:flex; align-items:center; justify-content:center; opacity:.9}
  /* cajas gruesas */
  .cell[data-r="2"], .cell[data-r="5"]{border-bottom:3px solid var(--grid)}
  .cell[data-c="2"], .cell[data-c="5"]{border-right:3px solid var(--grid)}
  .controls{
    display:grid; gap:10px; grid-template-columns:repeat(3,1fr); max-width:820px; margin:0 auto;
  }
  .row{display:flex; gap:10px; flex-wrap:wrap; justify-content:center}
  button, .dd{
    appearance:none; border:none; background:var(--accent); color:#0b0f12; font-weight:800; padding:12px 14px; border-radius:12px;
    cursor:pointer; box-shadow:0 8px 18px rgba(0,229,255,.25); transition:transform .05s ease, opacity .15s ease;
  }
  button.secondary{background:var(--card); color:var(--text); border:1px solid var(--grid); box-shadow:none}
  button.warn{background:var(--warn); color:#111}
  button.ok{background:var(--ok); color:#111}
  button:disabled{opacity:.5; cursor:not-allowed}
  button:active{transform:translateY(1px) scale(.99)}
  .keypad{display:grid; grid-template-columns:repeat(5,1fr); gap:8px}
  .key{padding:12px 0; background:var(--card); border:1px solid var(--grid); border-radius:12px; text-align:center; font-weight:800; color:var(--text)}
  .key:active{transform:translateY(1px) scale(.98)}
  .legend{display:flex; gap:10px; justify-content:center; color:var(--muted); font-size:14px}
  .footer{color:var(--muted); text-align:center; padding:6px 12px 18px}
  @media (min-width:760px){
    .controls{grid-template-columns:1fr 1fr 1fr}
  }
</style>
</head>
<body>
<header>
  <div style="font-size:20px">NGS-Games ¬∑ <span style="color:var(--accent)">Sudoku</span></div>
</header>

<div class="app">
  <div class="topbar">
    <span class="badge">‚è±Ô∏è <span id="timer">00:00</span></span>
    <span class="badge">‚ùå Errores: <span id="mistakes">0</span></span>
    <span class="badge">üß© Dificultad: 
      <select id="difficulty" class="dd" style="margin-left:6px; background:var(--card); color:var(--text); border:1px solid var(--grid); padding:6px 10px; border-radius:10px">
        <option value="easy">F√°cil</option>
        <option value="medium" selected>Medio</option>
        <option value="hard">Dif√≠cil</option>
      </select>
    </span>
    <button id="newBtn">Nuevo</button>
    <button id="checkBtn" class="secondary">Verificar</button>
    <button id="hintBtn" class="secondary">Pista</button>
    <button id="solveBtn" class="warn">Resolver</button>
  </div>

  <div class="board-wrap">
    <div id="board" class="board" aria-label="Tablero de Sudoku"></div>
  </div>

  <div class="controls">
    <div class="row">
      <button id="notesToggle" class="secondary">‚úèÔ∏è Notas: OFF</button>
      <button id="eraseBtn" class="secondary">üßπ Borrar</button>
      <button id="clearBtn" class="secondary">Limpiar</button>
    </div>
    <div class="keypad">
      <div class="key" data-k="1">1</div>
      <div class="key" data-k="2">2</div>
      <div class="key" data-k="3">3</div>
      <div class="key" data-k="4">4</div>
      <div class="key" data-k="5">5</div>
      <div class="key" data-k="6">6</div>
      <div class="key" data-k="7">7</div>
      <div class="key" data-k="8">8</div>
      <div class="key" data-k="9">9</div>
      <div class="key" data-k="0">‚å´</div>
    </div>
    <div class="row">
      <button id="undoBtn" class="secondary">‚Ü∂ Deshacer</button>
      <button id="redoBtn" class="secondary">‚Ü∑ Rehacer</button>
      <button id="giveUpBtn" class="warn">Rendirse</button>
    </div>
  </div>

  <div class="legend">Consejo: activ√° <b>Notas</b> para poner candidatos. Doble clic borra notas de una celda.</div>
  <div class="footer">Hecho para NGS-Games ¬∑ Guarda este archivo como <b>Sudoku.html</b></div>
</div>

<script>
(() => {
  // ======== Estado y utilidades ========
  const boardEl = document.getElementById('board');
  const timerEl = document.getElementById('timer');
  const mistakesEl = document.getElementById('mistakes');
  const notesToggle = document.getElementById('notesToggle');
  const newBtn = document.getElementById('newBtn');
  const checkBtn = document.getElementById('checkBtn');
  const solveBtn = document.getElementById('solveBtn');
  const hintBtn = document.getElementById('hintBtn');
  const eraseBtn = document.getElementById('eraseBtn');
  const clearBtn = document.getElementById('clearBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const giveUpBtn = document.getElementById('giveUpBtn');
  const difficultySel = document.getElementById('difficulty');

  let grid = Array.from({length:9}, ()=>Array(9).fill(0));         // tablero actual
  let solution = Array.from({length:9}, ()=>Array(9).fill(0));     // soluci√≥n verdadera
  let fixed = Array.from({length:9}, ()=>Array(9).fill(false));    // celdas fijas
  let notes = Array.from({length:9}, ()=>Array.from({length:9},()=>new Set())); // candidatos por celda
  let sel = {r:0, c:0};                                            // celda seleccionada
  let notesMode = false;
  let mistakes = 0;
  let t0 = 0, timerId = null;

  // Historial para deshacer/rehacer
  const undoStack = [];
  const redoStack = [];
  function pushHistory(prev, next){
    undoStack.push(JSON.stringify({prev,next}));
    redoStack.length = 0;
    updateUndoRedo();
  }
  function updateUndoRedo(){
    undoBtn.disabled = undoStack.length===0;
    redoBtn.disabled = redoStack.length===0;
  }

  // Helpers
  const inRange = (r,c)=> r>=0 && r<9 && c>=0 && c<9;
  function clone2D(a){ return a.map(row=>row.slice()); }

  function setCell(r,c,val, recordHistory=true){
    if (fixed[r][c]) return;
    const prev = {grid:clone2D(grid), notes:notes.map(row=>row.map(s=>new Set([...s])))};
    grid[r][c]=val;
    if (val!==0) notes[r][c].clear();
    if (recordHistory) pushHistory(prev, {grid:clone2D(grid), notes:notes.map(row=>row.map(s=>new Set([...s])))});
    render();
  }

  function toggleNote(r,c,val, recordHistory=true){
    if (fixed[r][c]) return;
    const prev = {grid:clone2D(grid), notes:notes.map(row=>row.map(s=>new Set([...s])))};
    if (notes[r][c].has(val)) notes[r][c].delete(val);
    else notes[r][c].add(val);
    if (recordHistory) pushHistory(prev, {grid:clone2D(grid), notes:notes.map(row=>row.map(s=>new Set([...s])))});
    render();
  }

  function clearCell(r,c){
    if (fixed[r][c]) return;
    setCell(r,c,0);
  }

  // ======== L√≥gica Sudoku (solver + generador) ========
  function isValid(g, r, c, v){
    for (let i=0;i<9;i++){ if (g[r][i]===v || g[i][c]===v) return false; }
    const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
    for (let i=0;i<3;i++) for (let j=0;j<3;j++) if (g[br+i][bc+j]===v) return false;
    return true;
  }

  function findEmpty(g){
    let best=null, bestCount=10;
    for (let r=0;r<9;r++) for (let c=0;c<9;c++){
      if (g[r][c]===0){
        let cnt=0;
        for (let v=1; v<=9; v++) if (isValid(g,r,c,v)) cnt++;
        if (cnt < bestCount){ best={r,c}; bestCount=cnt; if (cnt===1) return best; }
      }
    }
    return best;
  }

  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
    return arr;
  }

  // Backtracking para resolver ‚Äì devuelve boolean. Si wantCount, cuenta hasta 2 soluciones.
  function solve(g, wantCount=false){
    let count=0;
    function bt(){
      const emp = findEmpty(g);
      if (!emp){ count++; return true; }
      const {r,c}=emp;
      const nums = shuffle([1,2,3,4,5,6,7,8,9]);
      for (const v of nums){
        if (isValid(g,r,c,v)){
          g[r][c]=v;
          if (bt()){
            if (!wantCount) return true; // primera soluci√≥n suficiente
          }
          if (wantCount && count>=2){ g[r][c]=0; return true; } // cortar si ya hay 2+
          g[r][c]=0;
        }
      }
      return false;
    }
    const ok = bt();
    return wantCount ? count : ok;
  }

  function generateFull(){
    const g = Array.from({length:9}, ()=>Array(9).fill(0));
    // Relleno por filas con backtracking aleatorio
    function fill(){
      const emp=findEmpty(g);
      if (!emp) return true;
      const {r,c}=emp;
      for (const v of shuffle([1,2,3,4,5,6,7,8,9])){
        if (isValid(g,r,c,v)){
          g[r][c]=v;
          if (fill()) return true;
          g[r][c]=0;
        }
      }
      return false;
    }
    fill();
    return g;
  }

  function generatePuzzle(level='medium'){
    // Claves aproximadas
    const clues = level==='easy' ? 40 : level==='hard' ? 26 : 32; // pista: m√°s bajo = m√°s dif√≠cil
    // 1) Crear soluci√≥n completa
    const full = generateFull();
    // 2) Quitar n√∫meros manteniendo soluci√≥n √∫nica
    const puzzle = clone2D(full);
    const cells = shuffle([...Array(81).keys()]);
    let removed = 0;
    for (const idx of cells){
      if (81 - removed <= clues) break;
      const r = Math.floor(idx/9), c = idx%9;
      const backup = puzzle[r][c];
      if (backup===0) continue;
      puzzle[r][c]=0;

      // Chequear unicidad
      const g = clone2D(puzzle);
      const solCount = solve(g, true); // cuenta hasta 2
      if (solCount !== 1){
        puzzle[r][c]=backup; // no √∫nico, revertir
      } else {
        removed++;
      }
    }
    return {puzzle, full};
  }

  // ======== Render ========
  function render(){
    // Redibujar celdas (clases de estado y contenido)
    for (let i=0;i<81;i++){
      const r=Math.floor(i/9), c=i%9;
      const cell = boardEl.children[i];
      const v = grid[r][c];
      cell.classList.toggle('lock', fixed[r][c]);
      cell.classList.toggle('sel', sel.r===r && sel.c===c);

      // peers / same number
      const same = v!==0 ? v : -1;
      const inPeer = (r===sel.r || c===sel.c || (Math.floor(r/3)===Math.floor(sel.r/3) && Math.floor(c/3)===Math.floor(sel.c/3)));
      const sameAsSel = (grid[sel.r][sel.c]!==0 && v===grid[sel.r][sel.c]);
      cell.classList.toggle('peer', inPeer);
      cell.classList.toggle('same', sameAsSel);

      // conflictos
      let conflict=false;
      if (v!==0){
        for (let k=0;k<9;k++){
          if (k!==c && grid[r][k]===v) conflict=true;
          if (k!==r && grid[k][c]===v) conflict=true;
        }
        const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
        for (let rr=0; rr<3; rr++) for (let cc=0; cc<3; cc++){
          const R=br+rr, C=bc+cc;
          if (!(R===r && C===c) && grid[R][C]===v) conflict=true;
        }
      }
      cell.classList.toggle('conflict', conflict);

      // contenido
      const valEl = cell.querySelector('.val');
      const notesEl = cell.querySelector('.notes');
      valEl.textContent = v===0 ? '' : v;
      notesEl.innerHTML = '';
      if (v===0 && notes[r][c].size){
        for (let k=1;k<=9;k++){
          const span=document.createElement('div');
          span.className='n';
          span.textContent = notes[r][c].has(k) ? k : '';
          notesEl.appendChild(span);
        }
      }
    }
    notesToggle.textContent = `‚úèÔ∏è Notas: ${notesMode?'ON':'OFF'}`;
    mistakesEl.textContent = mistakes;
    // Victoria
    if (isComplete()){
      stopTimer();
      setTimeout(()=>alert(`¬°Completado en ${timerEl.textContent} con ${mistakes} errores!`), 50);
    }
  }

  function isComplete(){
    for (let r=0;r<9;r++) for (let c=0;c<9;c++){
      if (grid[r][c]!==solution[r][c]) return false;
    }
    return true;
  }

  // ======== Construir UI tablero ========
  function buildBoard(){
    boardEl.innerHTML='';
    for (let r=0;r<9;r++) for (let c=0;c<9;c++){
      const cell=document.createElement('div');
      cell.className='cell';
      cell.dataset.r=r; cell.dataset.c=c;
      const val=document.createElement('div'); val.className='val';
      const notesDiv=document.createElement('div'); notesDiv.className='notes';
      cell.appendChild(val); cell.appendChild(notesDiv);
      boardEl.appendChild(cell);

      cell.addEventListener('click', ()=>{ sel={r,c}; render(); });
      cell.addEventListener('dblclick', ()=>{
        if (!fixed[r][c]){ notes[r][c].clear(); render(); }
      });
    }
  }

  // ======== Timer ========
  function startTimer(){
    t0 = Date.now();
    if (timerId) clearInterval(timerId);
    timerId = setInterval(()=>{
      const t = Math.floor((Date.now()-t0)/1000);
      const mm = String(Math.floor(t/60)).padStart(2,'0');
      const ss = String(t%60).padStart(2,'0');
      timerEl.textContent = `${mm}:${ss}`;
    }, 500);
  }
  function stopTimer(){ if (timerId){ clearInterval(timerId); timerId=null; } }

  // ======== Nueva partida ========
  function newGame(level=difficultySel.value){
    stopTimer();
    mistakes = 0;
    undoStack.length=0; redoStack.length=0; updateUndoRedo();
    const {puzzle, full} = generatePuzzle(level);
    grid = clone2D(puzzle);
    solution = clone2D(full);
    fixed = grid.map(row=>row.map(v=>v!==0));
    notes = Array.from({length:9}, ()=>Array.from({length:9},()=>new Set()));
    sel = {r:0,c:0};
    buildBoard();
    render();
    startTimer();
  }

  // ======== Entradas (numeros/acciones) ========
  function handleNumber(n){
    const {r,c}=sel;
    if (!inRange(r,c) || fixed[r][c]) return;
    if (notesMode){
      if (n===0){ notes[r][c].clear(); render(); return; }
      toggleNote(r,c,n);
      return;
    }
    const prevVal = grid[r][c];
    if (n===0){ setCell(r,c,0); return; }
    setCell(r,c,n);
    if (solution[r][c]!==n){
      mistakes++;
      mistakesEl.textContent = mistakes;
    }
  }

  // teclado f√≠sico
  window.addEventListener('keydown', (e)=>{
    if (e.key>='1'&&e.key<='9'){ handleNumber(parseInt(e.key,10)); }
    else if (e.key==='Backspace' || e.key==='Delete' || e.key==='0'){ handleNumber(0); }
    else if (e.key==='ArrowUp'){ sel.r = Math.max(0, sel.r-1); render(); }
    else if (e.key==='ArrowDown'){ sel.r = Math.min(8, sel.r+1); render(); }
    else if (e.key==='ArrowLeft'){ sel.c = Math.max(0, sel.c-1); render(); }
    else if (e.key==='ArrowRight'){ sel.c = Math.min(8, sel.c+1); render(); }
    else if (e.key.toLowerCase()==='n'){ notesMode=!notesMode; render(); }
  });

  // keypad t√°ctil
  document.querySelectorAll('.key').forEach(k=>{
    k.addEventListener('click', ()=> handleNumber(parseInt(k.dataset.k,10)));
  });

  // botones
  notesToggle.addEventListener('click', ()=>{ notesMode=!notesMode; render(); });
  eraseBtn.addEventListener('click', ()=> handleNumber(0));
  clearBtn.addEventListener('click', ()=>{
    const prev = {grid:clone2D(grid), notes:notes.map(row=>row.map(s=>new Set([...s])))};
    for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (!fixed[r][c]){ grid[r][c]=0; notes[r][c].clear(); }
    pushHistory(prev, {grid:clone2D(grid), notes:notes.map(row=>row.map(s=>new Set([...s])))});
    render();
  });

  undoBtn.addEventListener('click', ()=>{
    if (undoStack.length===0) return;
    const last = JSON.parse(undoStack.pop());
    redoStack.push(JSON.stringify(last));
    grid = clone2D(last.prev.grid);
    notes = last.prev.notes.map(row=>row.map(s=>new Set([...s])));
    updateUndoRedo(); render();
  });

  redoBtn.addEventListener('click', ()=>{
    if (redoStack.length===0) return;
    const step = JSON.parse(redoStack.pop());
    undoStack.push(JSON.stringify(step));
    grid = clone2D(step.next.grid);
    notes = step.next.notes.map(row=>row.map(s=>new Set([...s])));
    updateUndoRedo(); render();
  });

  checkBtn.addEventListener('click', ()=>{
    // marca conflictos visibles por un segundo
    const hadError = markConflictsOnce();
    if (!hadError && !hasZeros(grid)) alert('¬°Todo correcto hasta ahora!');
  });

  function hasZeros(g){ for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (g[r][c]===0) return true; return false; }

  function markConflictsOnce(){
    let error=false;
    for (let r=0;r<9;r++) for (let c=0;c<9;c++){
      const v=grid[r][c];
      if (v===0) continue;
      if (!isValid(grid.map(row=>row.slice()), r, c, v)){
        error=true;
      }else{
        // check duplicates excluding itself
        grid[r][c]=0;
        const ok = isValid(grid, r, c, v);
        grid[r][c]=v;
        if (!ok) error=true;
      }
    }
    // resaltado ya lo hace render(); ac√° solo feedback
    render();
    return error;
  }

  hintBtn.addEventListener('click', ()=>{
    // Busca una celda vac√≠a y la rellena con la soluci√≥n
    for (let r=0;r<9;r++) for (let c=0;c<9;c++){
      if (grid[r][c]===0){
        setCell(r,c,solution[r][c]);
        return;
      }
    }
  });

  solveBtn.addEventListener('click', ()=>{
    const prev = {grid:clone2D(grid), notes:notes.map(row=>row.map(s=>new Set([...s])))};
    grid = clone2D(solution);
    pushHistory(prev, {grid:clone2D(grid), notes:notes.map(row=>row.map(s=>new Set([...s])))});
    render(); stopTimer();
  });

  newBtn.addEventListener('click', ()=> newGame(difficultySel.value));
  difficultySel.addEventListener('change', ()=> newGame(difficultySel.value));
  giveUpBtn.addEventListener('click', ()=> solveBtn.click());

  // ======== Inicio ========
  buildBoard();
  newGame('medium');
})();
</script>
</body>
</html>
